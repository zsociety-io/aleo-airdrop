import credits.aleo;
import token_registry.aleo;
program token_registry_airdrop_32b.aleo;

struct TokenMetadata:
    token_id as field;
    name as u128;
    symbol as u128;
    decimals as u8;
    supply as u128;
    max_supply as u128;
    admin as address;
    external_authorization_required as boolean;
    external_authorization_party as address;

struct TokenOwner:
    account as address;
    token_id as field;

struct Project:
    admin as address;
    token_id as field;
    merkle_root as field;

struct Airdrop:
    project_id as field;
    recipient as address;
    amount as u128;

mapping projects:
    key as field.public;
    value as Project.public;

mapping claimed:
    key as field.public;
    value as boolean.public;

mapping balances:
    key as field.public;
    value as u128.public;

function create_airdrop_project:
    input r0 as field.public;
    input r1 as field.public;
    input r2 as field.public;
    input r3 as u128.public;
    call token_registry.aleo/transfer_public_as_signer r1 token_registry_airdrop_32b.aleo r3 into r4;
    async create_airdrop_project r0 self.caller r1 r2 r3 r4 into r5;
    output r5 as token_registry_airdrop_32b.aleo/create_airdrop_project.future;

finalize create_airdrop_project:
    input r0 as field.public;
    input r1 as address.public;
    input r2 as field.public;
    input r3 as field.public;
    input r4 as u128.public;
    input r5 as token_registry.aleo/transfer_public_as_signer.future;
    cast r1 r2 r3 into r6 as Project;
    contains projects[r0] into r7;
    not r7 into r8;
    assert.eq r8 true;
    set r6 into projects[r0];
    set r4 into balances[r0];
    await r5;

function update_airdrop_project:
    input r0 as field.public;
    input r1 as address.public;
    input r2 as field.public;
    async update_airdrop_project r0 self.caller r1 r2 into r3;
    output r3 as token_registry_airdrop_32b.aleo/update_airdrop_project.future;

finalize update_airdrop_project:
    input r0 as field.public;
    input r1 as address.public;
    input r2 as address.public;
    input r3 as field.public;
    get projects[r0] into r4;
    assert.eq r1 r4.admin;
    cast r2 r4.token_id r3 into r5 as Project;
    set r5 into projects[r0];

function claim_airdrop:
    input r0 as field.public;
    input r1 as field.public;
    input r2 as field.public;
    input r3 as scalar.private;
    input r4 as u128.private;
    input r5 as u32.private;
    input r6 as [field; 32u32].private;
    cast r0 self.signer r4 into r7 as Airdrop;
    hash.bhp256 r7 into r8 as field;
    commit.bhp256 r8 r3 into r9 as field;
    mod r5 2u32 into r10;
    is.eq r10 0u32 into r11;
    cast  r9 r6[0u32] into r12 as [field; 2u32];
    cast  r6[0u32] r9 into r13 as [field; 2u32];
    ternary r11 r12[0u32] r13[0u32] into r14;
    ternary r11 r12[1u32] r13[1u32] into r15;
    cast  r14 r15 into r16 as [field; 2u32];
    hash.bhp256 r16 into r17 as field;
    div r5 2u32 into r18;
    mod r18 2u32 into r19;
    is.eq r19 0u32 into r20;
    cast  r17 r6[1u32] into r21 as [field; 2u32];
    cast  r6[1u32] r17 into r22 as [field; 2u32];
    ternary r20 r21[0u32] r22[0u32] into r23;
    ternary r20 r21[1u32] r22[1u32] into r24;
    cast  r23 r24 into r25 as [field; 2u32];
    hash.bhp256 r25 into r26 as field;
    div r18 2u32 into r27;
    mod r27 2u32 into r28;
    is.eq r28 0u32 into r29;
    cast  r26 r6[2u32] into r30 as [field; 2u32];
    cast  r6[2u32] r26 into r31 as [field; 2u32];
    ternary r29 r30[0u32] r31[0u32] into r32;
    ternary r29 r30[1u32] r31[1u32] into r33;
    cast  r32 r33 into r34 as [field; 2u32];
    hash.bhp256 r34 into r35 as field;
    div r27 2u32 into r36;
    mod r36 2u32 into r37;
    is.eq r37 0u32 into r38;
    cast  r35 r6[3u32] into r39 as [field; 2u32];
    cast  r6[3u32] r35 into r40 as [field; 2u32];
    ternary r38 r39[0u32] r40[0u32] into r41;
    ternary r38 r39[1u32] r40[1u32] into r42;
    cast  r41 r42 into r43 as [field; 2u32];
    hash.bhp256 r43 into r44 as field;
    div r36 2u32 into r45;
    mod r45 2u32 into r46;
    is.eq r46 0u32 into r47;
    cast  r44 r6[4u32] into r48 as [field; 2u32];
    cast  r6[4u32] r44 into r49 as [field; 2u32];
    ternary r47 r48[0u32] r49[0u32] into r50;
    ternary r47 r48[1u32] r49[1u32] into r51;
    cast  r50 r51 into r52 as [field; 2u32];
    hash.bhp256 r52 into r53 as field;
    div r45 2u32 into r54;
    mod r54 2u32 into r55;
    is.eq r55 0u32 into r56;
    cast  r53 r6[5u32] into r57 as [field; 2u32];
    cast  r6[5u32] r53 into r58 as [field; 2u32];
    ternary r56 r57[0u32] r58[0u32] into r59;
    ternary r56 r57[1u32] r58[1u32] into r60;
    cast  r59 r60 into r61 as [field; 2u32];
    hash.bhp256 r61 into r62 as field;
    div r54 2u32 into r63;
    mod r63 2u32 into r64;
    is.eq r64 0u32 into r65;
    cast  r62 r6[6u32] into r66 as [field; 2u32];
    cast  r6[6u32] r62 into r67 as [field; 2u32];
    ternary r65 r66[0u32] r67[0u32] into r68;
    ternary r65 r66[1u32] r67[1u32] into r69;
    cast  r68 r69 into r70 as [field; 2u32];
    hash.bhp256 r70 into r71 as field;
    div r63 2u32 into r72;
    mod r72 2u32 into r73;
    is.eq r73 0u32 into r74;
    cast  r71 r6[7u32] into r75 as [field; 2u32];
    cast  r6[7u32] r71 into r76 as [field; 2u32];
    ternary r74 r75[0u32] r76[0u32] into r77;
    ternary r74 r75[1u32] r76[1u32] into r78;
    cast  r77 r78 into r79 as [field; 2u32];
    hash.bhp256 r79 into r80 as field;
    div r72 2u32 into r81;
    mod r81 2u32 into r82;
    is.eq r82 0u32 into r83;
    cast  r80 r6[8u32] into r84 as [field; 2u32];
    cast  r6[8u32] r80 into r85 as [field; 2u32];
    ternary r83 r84[0u32] r85[0u32] into r86;
    ternary r83 r84[1u32] r85[1u32] into r87;
    cast  r86 r87 into r88 as [field; 2u32];
    hash.bhp256 r88 into r89 as field;
    div r81 2u32 into r90;
    mod r90 2u32 into r91;
    is.eq r91 0u32 into r92;
    cast  r89 r6[9u32] into r93 as [field; 2u32];
    cast  r6[9u32] r89 into r94 as [field; 2u32];
    ternary r92 r93[0u32] r94[0u32] into r95;
    ternary r92 r93[1u32] r94[1u32] into r96;
    cast  r95 r96 into r97 as [field; 2u32];
    hash.bhp256 r97 into r98 as field;
    div r90 2u32 into r99;
    mod r99 2u32 into r100;
    is.eq r100 0u32 into r101;
    cast  r98 r6[10u32] into r102 as [field; 2u32];
    cast  r6[10u32] r98 into r103 as [field; 2u32];
    ternary r101 r102[0u32] r103[0u32] into r104;
    ternary r101 r102[1u32] r103[1u32] into r105;
    cast  r104 r105 into r106 as [field; 2u32];
    hash.bhp256 r106 into r107 as field;
    div r99 2u32 into r108;
    mod r108 2u32 into r109;
    is.eq r109 0u32 into r110;
    cast  r107 r6[11u32] into r111 as [field; 2u32];
    cast  r6[11u32] r107 into r112 as [field; 2u32];
    ternary r110 r111[0u32] r112[0u32] into r113;
    ternary r110 r111[1u32] r112[1u32] into r114;
    cast  r113 r114 into r115 as [field; 2u32];
    hash.bhp256 r115 into r116 as field;
    div r108 2u32 into r117;
    mod r117 2u32 into r118;
    is.eq r118 0u32 into r119;
    cast  r116 r6[12u32] into r120 as [field; 2u32];
    cast  r6[12u32] r116 into r121 as [field; 2u32];
    ternary r119 r120[0u32] r121[0u32] into r122;
    ternary r119 r120[1u32] r121[1u32] into r123;
    cast  r122 r123 into r124 as [field; 2u32];
    hash.bhp256 r124 into r125 as field;
    div r117 2u32 into r126;
    mod r126 2u32 into r127;
    is.eq r127 0u32 into r128;
    cast  r125 r6[13u32] into r129 as [field; 2u32];
    cast  r6[13u32] r125 into r130 as [field; 2u32];
    ternary r128 r129[0u32] r130[0u32] into r131;
    ternary r128 r129[1u32] r130[1u32] into r132;
    cast  r131 r132 into r133 as [field; 2u32];
    hash.bhp256 r133 into r134 as field;
    div r126 2u32 into r135;
    mod r135 2u32 into r136;
    is.eq r136 0u32 into r137;
    cast  r134 r6[14u32] into r138 as [field; 2u32];
    cast  r6[14u32] r134 into r139 as [field; 2u32];
    ternary r137 r138[0u32] r139[0u32] into r140;
    ternary r137 r138[1u32] r139[1u32] into r141;
    cast  r140 r141 into r142 as [field; 2u32];
    hash.bhp256 r142 into r143 as field;
    div r135 2u32 into r144;
    mod r144 2u32 into r145;
    is.eq r145 0u32 into r146;
    cast  r143 r6[15u32] into r147 as [field; 2u32];
    cast  r6[15u32] r143 into r148 as [field; 2u32];
    ternary r146 r147[0u32] r148[0u32] into r149;
    ternary r146 r147[1u32] r148[1u32] into r150;
    cast  r149 r150 into r151 as [field; 2u32];
    hash.bhp256 r151 into r152 as field;
    div r144 2u32 into r153;
    mod r153 2u32 into r154;
    is.eq r154 0u32 into r155;
    cast  r152 r6[16u32] into r156 as [field; 2u32];
    cast  r6[16u32] r152 into r157 as [field; 2u32];
    ternary r155 r156[0u32] r157[0u32] into r158;
    ternary r155 r156[1u32] r157[1u32] into r159;
    cast  r158 r159 into r160 as [field; 2u32];
    hash.bhp256 r160 into r161 as field;
    div r153 2u32 into r162;
    mod r162 2u32 into r163;
    is.eq r163 0u32 into r164;
    cast  r161 r6[17u32] into r165 as [field; 2u32];
    cast  r6[17u32] r161 into r166 as [field; 2u32];
    ternary r164 r165[0u32] r166[0u32] into r167;
    ternary r164 r165[1u32] r166[1u32] into r168;
    cast  r167 r168 into r169 as [field; 2u32];
    hash.bhp256 r169 into r170 as field;
    div r162 2u32 into r171;
    mod r171 2u32 into r172;
    is.eq r172 0u32 into r173;
    cast  r170 r6[18u32] into r174 as [field; 2u32];
    cast  r6[18u32] r170 into r175 as [field; 2u32];
    ternary r173 r174[0u32] r175[0u32] into r176;
    ternary r173 r174[1u32] r175[1u32] into r177;
    cast  r176 r177 into r178 as [field; 2u32];
    hash.bhp256 r178 into r179 as field;
    div r171 2u32 into r180;
    mod r180 2u32 into r181;
    is.eq r181 0u32 into r182;
    cast  r179 r6[19u32] into r183 as [field; 2u32];
    cast  r6[19u32] r179 into r184 as [field; 2u32];
    ternary r182 r183[0u32] r184[0u32] into r185;
    ternary r182 r183[1u32] r184[1u32] into r186;
    cast  r185 r186 into r187 as [field; 2u32];
    hash.bhp256 r187 into r188 as field;
    div r180 2u32 into r189;
    mod r189 2u32 into r190;
    is.eq r190 0u32 into r191;
    cast  r188 r6[20u32] into r192 as [field; 2u32];
    cast  r6[20u32] r188 into r193 as [field; 2u32];
    ternary r191 r192[0u32] r193[0u32] into r194;
    ternary r191 r192[1u32] r193[1u32] into r195;
    cast  r194 r195 into r196 as [field; 2u32];
    hash.bhp256 r196 into r197 as field;
    div r189 2u32 into r198;
    mod r198 2u32 into r199;
    is.eq r199 0u32 into r200;
    cast  r197 r6[21u32] into r201 as [field; 2u32];
    cast  r6[21u32] r197 into r202 as [field; 2u32];
    ternary r200 r201[0u32] r202[0u32] into r203;
    ternary r200 r201[1u32] r202[1u32] into r204;
    cast  r203 r204 into r205 as [field; 2u32];
    hash.bhp256 r205 into r206 as field;
    div r198 2u32 into r207;
    mod r207 2u32 into r208;
    is.eq r208 0u32 into r209;
    cast  r206 r6[22u32] into r210 as [field; 2u32];
    cast  r6[22u32] r206 into r211 as [field; 2u32];
    ternary r209 r210[0u32] r211[0u32] into r212;
    ternary r209 r210[1u32] r211[1u32] into r213;
    cast  r212 r213 into r214 as [field; 2u32];
    hash.bhp256 r214 into r215 as field;
    div r207 2u32 into r216;
    mod r216 2u32 into r217;
    is.eq r217 0u32 into r218;
    cast  r215 r6[23u32] into r219 as [field; 2u32];
    cast  r6[23u32] r215 into r220 as [field; 2u32];
    ternary r218 r219[0u32] r220[0u32] into r221;
    ternary r218 r219[1u32] r220[1u32] into r222;
    cast  r221 r222 into r223 as [field; 2u32];
    hash.bhp256 r223 into r224 as field;
    div r216 2u32 into r225;
    mod r225 2u32 into r226;
    is.eq r226 0u32 into r227;
    cast  r224 r6[24u32] into r228 as [field; 2u32];
    cast  r6[24u32] r224 into r229 as [field; 2u32];
    ternary r227 r228[0u32] r229[0u32] into r230;
    ternary r227 r228[1u32] r229[1u32] into r231;
    cast  r230 r231 into r232 as [field; 2u32];
    hash.bhp256 r232 into r233 as field;
    div r225 2u32 into r234;
    mod r234 2u32 into r235;
    is.eq r235 0u32 into r236;
    cast  r233 r6[25u32] into r237 as [field; 2u32];
    cast  r6[25u32] r233 into r238 as [field; 2u32];
    ternary r236 r237[0u32] r238[0u32] into r239;
    ternary r236 r237[1u32] r238[1u32] into r240;
    cast  r239 r240 into r241 as [field; 2u32];
    hash.bhp256 r241 into r242 as field;
    div r234 2u32 into r243;
    mod r243 2u32 into r244;
    is.eq r244 0u32 into r245;
    cast  r242 r6[26u32] into r246 as [field; 2u32];
    cast  r6[26u32] r242 into r247 as [field; 2u32];
    ternary r245 r246[0u32] r247[0u32] into r248;
    ternary r245 r246[1u32] r247[1u32] into r249;
    cast  r248 r249 into r250 as [field; 2u32];
    hash.bhp256 r250 into r251 as field;
    div r243 2u32 into r252;
    mod r252 2u32 into r253;
    is.eq r253 0u32 into r254;
    cast  r251 r6[27u32] into r255 as [field; 2u32];
    cast  r6[27u32] r251 into r256 as [field; 2u32];
    ternary r254 r255[0u32] r256[0u32] into r257;
    ternary r254 r255[1u32] r256[1u32] into r258;
    cast  r257 r258 into r259 as [field; 2u32];
    hash.bhp256 r259 into r260 as field;
    div r252 2u32 into r261;
    mod r261 2u32 into r262;
    is.eq r262 0u32 into r263;
    cast  r260 r6[28u32] into r264 as [field; 2u32];
    cast  r6[28u32] r260 into r265 as [field; 2u32];
    ternary r263 r264[0u32] r265[0u32] into r266;
    ternary r263 r264[1u32] r265[1u32] into r267;
    cast  r266 r267 into r268 as [field; 2u32];
    hash.bhp256 r268 into r269 as field;
    div r261 2u32 into r270;
    mod r270 2u32 into r271;
    is.eq r271 0u32 into r272;
    cast  r269 r6[29u32] into r273 as [field; 2u32];
    cast  r6[29u32] r269 into r274 as [field; 2u32];
    ternary r272 r273[0u32] r274[0u32] into r275;
    ternary r272 r273[1u32] r274[1u32] into r276;
    cast  r275 r276 into r277 as [field; 2u32];
    hash.bhp256 r277 into r278 as field;
    div r270 2u32 into r279;
    mod r279 2u32 into r280;
    is.eq r280 0u32 into r281;
    cast  r278 r6[30u32] into r282 as [field; 2u32];
    cast  r6[30u32] r278 into r283 as [field; 2u32];
    ternary r281 r282[0u32] r283[0u32] into r284;
    ternary r281 r282[1u32] r283[1u32] into r285;
    cast  r284 r285 into r286 as [field; 2u32];
    hash.bhp256 r286 into r287 as field;
    div r279 2u32 into r288;
    mod r288 2u32 into r289;
    is.eq r289 0u32 into r290;
    cast  r287 r6[31u32] into r291 as [field; 2u32];
    cast  r6[31u32] r287 into r292 as [field; 2u32];
    ternary r290 r291[0u32] r292[0u32] into r293;
    ternary r290 r291[1u32] r292[1u32] into r294;
    cast  r293 r294 into r295 as [field; 2u32];
    hash.bhp256 r295 into r296 as field;
    div r288 2u32 into r297;
    assert.eq r296 r2;
    call token_registry.aleo/transfer_public_to_private r1 self.signer r4 false into r298 r299;
    async claim_airdrop r9 r0 r2 r1 r4 r299 into r300;
    output r298 as token_registry.aleo/Token.record;
    output r300 as token_registry_airdrop_32b.aleo/claim_airdrop.future;

finalize claim_airdrop:
    input r0 as field.public;
    input r1 as field.public;
    input r2 as field.public;
    input r3 as field.public;
    input r4 as u128.public;
    input r5 as token_registry.aleo/transfer_public_to_private.future;
    contains claimed[r0] into r6;
    not r6 into r7;
    assert.eq r7 true;
    set true into claimed[r0];
    get projects[r1] into r8;
    assert.eq r2 r8.merkle_root;
    assert.eq r3 r8.token_id;
    get balances[r1] into r9;
    sub r9 r4 into r10;
    set r10 into balances[r1];
    await r5;
